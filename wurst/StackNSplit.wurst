/*
*  StackNSplit v1.0.0.0
*     by Bannar
*
*  Easy item charges stacking and splitting.
*/
package StackNSplit
import HashMap
import RegisterEvents
import InventoryEvent
import SmoothItemPickup

Table stackTable = new Table()

unit eventUnit = null
item eventItem = null
int eventCharges = 0
trigger eventAddedTrigger = CreateTrigger()
trigger eventRemovedTrigger = CreateTrigger()

public constant int EVENT_ITEM_CHARGES_ADDED = 0
public constant int EVENT_ITEM_CHARGES_REMOVED = 1

/** Returns unit which manupilated event item. */
public function getItemStackingUnit() returns unit
    return eventUnit

/** Returns manipulated event item. */
public function getItemStackingItem() returns item
    return eventItem

/** Returns number of charges that has been added or removed. */
public function getItemStackingCharges() returns int
    return eventCharges

/** Returns trigger handle associated with specified item stacking event. */
public function getItemStackingEventTrigger(int whichEvent) returns trigger
    if whichEvent == EVENT_ITEM_CHARGES_ADDED
        return eventAddedTrigger
    else if whichEvent == EVENT_ITEM_CHARGES_REMOVED
        return eventRemovedTrigger
    return null

/** Registers new event handler for specified item stacking event. */
public function registerItemStackingEvent(int whichEvent, code cb)
    if whichEvent == EVENT_ITEM_CHARGES_ADDED
        eventAddedTrigger.addCondition(Condition(cb))
    else if whichEvent == EVENT_ITEM_CHARGES_REMOVED
        eventRemovedTrigger.addCondition(Condition(cb))

/** Returns value indicating whether specified item is registered as stackable. */
public function isItemStackable(int itemTypeId) returns boolean
    return stackTable.hasInt(itemTypeId)

/** Registers specified item as stackable. */
public function makeItemStackable(int itemTypeId, int stacks, int splits)
    int value = splits

    if stacks > 0
        if value < 1
            value = 1
        stackTable.saveInt(itemTypeId, stacks)
        stackTable.saveInt(-itemTypeId, value)

/** Unregisters specified item from being stackable. */
public function makeItemUnstackable(int itemTypeId)
    stackTable.removeInt(itemTypeId)
    stackTable.removeInt(-itemTypeId)

/** Retrieves maximum amount of stacks for specified item. */
public function getItemMaxStacks(int itemTypeId) returns int
    if isItemStackable(itemTypeId)
        return stackTable.loadInt(itemTypeId)
    return 0

/** Retrieves number of stacks are dropped when splitting. This number is not final and can change during runtime
    if event item does not have required number of charges. Capped at minimum of 1. */
public function getItemSplitCount(int itemTypeId) returns int
    if isItemStackable(itemTypeId)
        return stackTable.loadInt(-itemTypeId)
    return 0

/** Checks if unit inventory is fully stacked and no charges can be added. */
public function unit.isItemFullyStacked(int itemTypeId) returns boolean
    boolean result = true
    item itm

    if not this.isInventoryFull()
        return false
    else if not isItemStackable(itemTypeId)
        return result

    int max = getItemMaxStacks(itemTypeId)
    if max > 0
        int size = this.inventorySize()
        for slot = 0 to size - 1
            itm = this.itemInSlot(slot)
            if itm.getTypeId() == itemTypeId and GetItemCharges(itm) < max
                result = false
                break
    return result

function fireEvent(trigger evt, unit u, item itm, int charges)
    unit prevUnit = eventUnit
    item prevItem = eventItem
    integer prevCharges = eventCharges

    eventUnit = u
    eventItem = itm
    eventCharges = charges

    evt.evaluate()

    eventUnit = prevUnit
    eventItem = prevItem
    eventCharges = prevCharges

/** Attempts to stack provided item for specified unit. */
public function unit.stackItem(item whichItem) returns boolean
    int charges = whichItem.getCharges()
    int itemTypeId = whichItem.getTypeId()
    int curr
    int diff
    int size = this.inventorySize()
    item with

    if charges == 0 or not isItemStackable(itemTypeId)
        return false

    int max = getItemMaxStacks(itemTypeId)
    for slot = 0 to size - 1
        with = this.itemInSlot(slot)

        if with != whichItem and with.getTypeId() == itemTypeId
            curr = with.getCharges()

            if curr < max
                diff = max - curr
                if diff > charges
                    with.setCharges(curr + charges)
                    fireEvent(eventAddedTrigger, this, with, charges)
                else
                    with.setCharges(max)
                    fireEvent(eventAddedTrigger, this, with, diff)
                charges -= diff
        if charges <= 0
            break

    if charges <= 0
        whichItem.remove()
    else if charges != whichItem.getCharges()
        whichItem.setCharges(charges)
    return true

function onPickUp()
    item itm = GetManipulatedItem()

    if isItemStackable(itm.getTypeId())
        GetTriggerUnit().stackItem(itm)

function onMoved()
    unit u = getInventoryManipulatingUnit()
    item itm = getInventoryManipulatedItem()
    int slotFrom = getInventorySlotFrom()
    item with = getInventorySwappedItem()
    int curr
    int diff
    int charges = itm.getCharges()
    int itemTypeId = itm.getTypeId()
    int size = u.inventorySize()
    int max
    int toSplit

    if not isItemStackable(itemTypeId)
        return

    max = getItemMaxStacks(itemTypeId)
    toSplit = getItemSplitCount(itemTypeId)

    if slotFrom == getInventorySlotTo() // splitting
        if charges < 2 // need at least 2
            return
        else if toSplit >= charges
            toSplit = charges - 1
        SetItemCharges(itm, charges - toSplit)
        fireEvent(eventRemovedTrigger, u, itm, toSplit)

        // Redistribute splitted stacks if possible
        for slot = 0 to size - 1
            if slot != slotFrom
                with = u.itemInSlot(slot)
                if with.getTypeId() == itemTypeId
                    curr = with.getCharges()
                    diff = max - curr
                    if diff > toSplit
                        with.setCharges(curr + toSplit)
                        fireEvent(eventAddedTrigger, u, with, toSplit)
                    else
                        with.setCharges(max)
                        fireEvent(eventAddedTrigger, u, with, diff)
                    toSplit -= diff
            if toSplit <= 0
                break
        if toSplit > 0 // something is left
            with = CreateItem(itemTypeId, u.getX(), u.getY())
            with.setCharges(toSplit)
            trigger t = getPlayerUnitEventTrigger(EVENT_PLAYER_UNIT_PICKUP_ITEM)
            t.disable()
            u.addItemHandle(with)
            t.enable()
    else if with.getTypeId() == itemTypeId
        curr = with.getCharges()
        toSplit = charges + curr

        if toSplit > max
            if curr < max
                diff = max - charges
                itm.setCharges(max)
                fireEvent(eventAddedTrigger, u, itm, diff)
                with.setCharges(toSplit - max)
                fireEvent(eventRemovedTrigger, u, with, diff)
        else
            with.setCharges(toSplit)
            fireEvent(eventAddedTrigger, u, with, charges)
            itm.remove()

function onSmoothPickup()
    getSmoothItemPickupUnit().stackItem(getSmoothItemPickupItem())

class StackSmoothPickupPredicate implements SmoothPickupPredicate
    function canPickup(unit u, item itm) returns boolean
        int itemTypeId = itm.getTypeId()
        if not isItemStackable(itemTypeId)
            return false

        return not u.isItemFullyStacked(itemTypeId)

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM, () -> onPickUp())
    registerInventoryEvent(EVENT_INVENTORY_MOVED, () -> onMoved())
    registerSmoothItemPickupEvent(() -> onSmoothPickup())
    addSmoothItemPickupCondition(new StackSmoothPickupPredicate())
