/*
*  StackNSplit v1.0.0.0
*     by Bannar
*
*  Easy item charges stacking and splitting.
*/
package StackNSplit
import HashMap
import RegisterEvents
import InventoryEvent
import SmoothItemPickup

Table stackTable = new Table()

unit eventUnit = null
item eventItem = null
int eventCharges = 0
trigger eventAddedTrigger = CreateTrigger()
trigger eventRemoveTrigger = CreateTrigger()

public constant int EVENT_ITEM_CHARGED_ADDED = 0
public constant int EVENT_ITEM_CHARGES_REMOVED = 1

public function getItemStackingUnit() returns unit
    return eventUnit

public function getItemStackingItem() returns item
    return eventItem

public function getItemStackingCharges() returns int
    return eventCharges

/** Registers new event handler for specified item recipe event. */
public function registerItemStackingEvent(int whichEvent, code c)
    if whichEvent == EVENT_ITEM_CHARGED_ADDED
        eventAddedTrigger.addCondition(Condition(c))
    else if whichEvent == EVENT_ITEM_CHARGES_REMOVED
        eventRemoveTrigger.addCondition(Condition(c))

/** Returns trigger handle associated with specified recipe event. */
public function getItemStackingEventTrigger(int whichEvent) returns trigger
    if whichEvent == EVENT_ITEM_CHARGED_ADDED
        return eventAddedTrigger
    else if whichEvent == EVENT_ITEM_CHARGES_REMOVED
        return eventRemoveTrigger
    return null

/** Checks if unit inventory is fully stacked and no charges can be added. */
public function unit.isItemFullyStacked(int itemTypeId) returns boolean
    boolean result = true
    int max = getItemMaxStacks(itemTypeId)
    item itm

    if max > 0
        int size = this.inventorySize()
        for slot = 0 to size - 1
            itm = this.itemInSlot(slot)
            if itm.getTypeId() == itemTypeId and GetItemCharges(itm) < max
                result = false
                break
    return result

function fireEvent(trigger evt, unit u, item itm, int charges)
    unit prevUnit = eventUnit
    item prevItem = eventItem
    integer prevCharges = eventCharges

    eventUnit = u
    eventItem = itm
    eventCharges = charges

    evt.evaluate()

    eventUnit = prevUnit
    eventItem = prevItem
    eventCharges = prevCharges

/** Returns value indicating whether specified item is registered as stackable. */
public function isItemStackable(int itemTypeId) returns boolean
    return stackTable.hasInt(itemTypeId)

/** Registers specified item as stackable. */
public function makeItemStackable(int itemTypeId, int stacks, int splits)
    int value = splits

    if stacks > 0
        if value < 1
            value = 1
        stackTable.saveInt(itemTypeId, stacks)
        stackTable.saveInt(-itemTypeId, value)

/** Unregisters specified item from being stackable. */
public function makeItemUnstackable(int itemTypeId)
    stackTable.removeInt(itemTypeId)
    stackTable.removeInt(-itemTypeId)

/** Retrieves maximum amount of stacks for specified item. */
public function getItemMaxStacks(int itemTypeId) returns int
    if isItemStackable(itemTypeId)
        return stackTable.loadInt(itemTypeId)
    return 0

/** Retrieves number of stacks are dropped when splitting. This number is not final and can change during runtime
    if event item does not have required number of charges. Capped at minimum of 1. */
public function getItemSplitCount(int itemTypeId) returns int
    if isItemStackable(itemTypeId)
        return stackTable.loadInt(-itemTypeId)
    return 0

/** Attempts to stack provided item for specified unit. */
public function stackItem(unit u, item itm) returns boolean
    int charges = itm.getCharges()
    int itemTypeId = itm.getTypeId()
    int curr
    int diff
    int size = u.inventorySize()
    item with

    if charges == 0 or not isItemStackable(itemTypeId)
        return false

    int max = getItemMaxStacks(itemTypeId)
    for slot = 0 to size - 1
        with = u.itemInSlot(slot)

        if with != itm and with.getTypeId() == itemTypeId
            curr = with.getCharges()

            if curr < max
                diff = max - curr
                if diff > charges
                    with.setCharges(curr + charges)
                    fireEvent(eventAddedTrigger, u, with, charges)
                else
                    with.setCharges(max)
                    fireEvent(eventAddedTrigger, u, with, diff)
                charges -= diff
        if charges <= 0
            break

    if charges <= 0
        itm.remove()
    else if charges != itm.getCharges()
        itm.setCharges(charges)
    return true

function onPickUp()
    item itm = GetManipulatedItem()

    if isItemStackable(itm.getTypeId())
        stackItem(GetTriggerUnit(), itm)

function onMoved()
    unit u = getInventoryManipulatingUnit()
    item itm = getInventoryManipulatedItem()
    int slotFrom = getInventorySlotFrom()
    item with = getInventorySwappedItem()
    int curr
    int diff
    int charges = itm.getCharges()
    int itemTypeId = itm.getTypeId()
    int size = u.inventorySize()
    int max
    int toSplit

    if not isItemStackable(itemTypeId)
        return

    max = getItemMaxStacks(itemTypeId)
    toSplit = getItemSplitCount(itemTypeId)

    if slotFrom == getInventorySlotTo() // splitting
        if charges < 2 // need at least 2
            return
        else if toSplit >= charges
            toSplit = charges - 1
        SetItemCharges(itm, charges - toSplit)
        fireEvent(eventRemoveTrigger, u, itm, toSplit)

        // Redistribute the splitted stacks if possible
        for slot = 0 to size - 1
            if slot != slotFrom
                with = u.itemInSlot(slot)
                if with.getTypeId() == itemTypeId
                    curr = with.getCharges()
                    diff = max - curr
                    if diff > toSplit
                        with.setCharges(curr + toSplit)
                        fireEvent(eventAddedTrigger, u, with, toSplit)
                    else
                        with.setCharges(max)
                        fireEvent(eventAddedTrigger, u, with, diff)
                    toSplit -= diff
            if toSplit <= 0
                break
        if toSplit > 0 // something is left
            with = CreateItem(itemTypeId, u.getX(), u.getY())
            with.setCharges(toSplit)
            trigger t = getPlayerUnitEventTrigger(EVENT_PLAYER_UNIT_PICKUP_ITEM)
            t.disable()
            u.addItemHandle(with)
            t.enable()
    else if with.getTypeId() == itemTypeId
        curr = with.getCharges()
        toSplit = charges + curr

        if toSplit > max
            if curr != max
                diff = max - charges
                itm.setCharges(max)
                fireEvent(eventAddedTrigger, u, itm, diff)
                with.setCharges(toSplit - max)
                fireEvent(eventRemoveTrigger, u, with, diff)
        else
            with.setCharges(toSplit)
            fireEvent(eventAddedTrigger, u, with, charges)
            itm.remove()

function onSmoothPickup()
    stackItem(getSmoothItemPickupUnit(), getSmoothItemPickupItem())

class StackSmoothPickupPredicate implements SmoothPickupPredicate

    function canPickup(unit u, item itm) returns boolean
        int itemTypeId = itm.getTypeId()
        if not isItemStackable(itemTypeId)
            return false

        return u.isInventoryFull() and not u.isItemFullyStacked(itemTypeId)

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM, () -> onPickUp())
    registerInventoryEvent(EVENT_INVENTORY_MOVED, () -> onMoved())
    registerSmoothItemPickupEvent(() -> onSmoothPickup())
    addSmoothPickupCondition(new StackSmoothPickupPredicate())
