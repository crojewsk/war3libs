/*
*  StackNSplit v1.0.0.0
*     by Bannar
*
*  Easy item charges stacking and splitting.
*/
package StackNSplit
import HashMap
import RegisterEvents
import InventoryEvent
import SmoothItemPickup

Table stackTable = new Table()

unit eventUnit = null
item eventItem = null
int eventCharges = 0
trigger eventAddedTrigger = CreateTrigger()
trigger eventRemoveTrigger = CreateTrigger()

public constant int EVENT_ITEM_CHARGED_ADDED = 0
public constant int EVENT_ITEM_CHARGES_REMOVED = 1

public function getItemStackingUnit() returns unit
    return eventUnit

public function getItemStackingItem() returns item
    return eventItem

public function getItemStackingCharges() returns int
    return eventCharges

/** Registers new event handler for specified item recipe event. */
public function registerItemStackingEvent(int whichEvent, code c)
    if whichEvent == EVENT_ITEM_CHARGED_ADDED
        eventAddedTrigger.addCondition(Condition(c))
    else if whichEvent == EVENT_ITEM_CHARGES_REMOVED
        eventRemoveTrigger.addCondition(Condition(c))

/** Returns trigger handle associated with specified recipe event. */
public function getItemStackingEventTrigger(int whichEvent) returns trigger
    if whichEvent == EVENT_ITEM_CHARGED_ADDED
        return eventAddedTrigger
    else if whichEvent == EVENT_ITEM_CHARGES_REMOVED
        return eventRemoveTrigger
    return null

/** Checks if unit inventory is full. */
public function unit.isInventoryFull() returns boolean
    let size = this.inventorySize()

    for i = 0 to size-1
        if this.itemInSlot(i) == null
            return false
    return true

/** Checks if unit inventory is fully stacked and no charges can be added. */
public function unit.isItemFullyStacked(int itemTypeId) returns boolean
    let max = getItemMaxStacks(itemTypeId)
    item itm

    if max > 0
        let size = this.inventorySize()
        for i = 0 to size-1
            itm = this.itemInSlot(i)
            if itm.getTypeId() == itemTypeId and GetItemCharges(itm) < max
                return false
    return true

function fireEvent(trigger evt, unit u, item itm, int charges)
    unit prevUnit = eventUnit
    item prevItem = eventItem
    integer prevCharges = eventCharges

    eventUnit = u
    eventItem = itm
    eventCharges = charges

    evt.evaluate()

    eventUnit = prevUnit
    eventItem = prevItem
    eventCharges = prevCharges

/** Returns value indicating whether specified item is registered as stackable. */
public function isItemStackable(int itemTypeId) returns boolean
    return stackTable.hasInt(itemTypeId)

/** Registers specified item as stackable. */
public function makeItemStackable(int itemTypeId, int stacks, int splits)
    int value = splits

    if stacks > 0
        if value < 1
            value = 1
        stackTable.saveInt(itemTypeId, stacks)
        stackTable.saveInt(-itemTypeId, value)

/** Unregisters specified item from being stackable. */
public function makeItemUnstackable(int itemTypeId)
    stackTable.removeInt(itemTypeId)
    stackTable.removeInt(-itemTypeId)

/** Retrieves maximum amount of stacks for specified item. */
public function getItemMaxStacks(int itemTypeId) returns int
    if isItemStackable(itemTypeId)
        return stackTable.loadInt(itemTypeId)
    return 0

/** Retrieves number of stacks are dropped when splitting. This number is not final and can change during runtime
    if event item does not have required number of charges. Capped at minimum of 1. */
public function getItemSplitCount(int itemTypeId) returns int
    if isItemStackable(itemTypeId)
        return stackTable.loadInt(-itemTypeId)
    return 0

/** Attempts to stack provided item for specified unit. */
public function stackItem(unit u, item itm) returns boolean
    int charges = GetItemCharges(itm)
    int itemTypeId = itm.getTypeId()
    int curr
    int diff
    int size = u.inventorySize()
    item with

    if charges == 0 or not isItemStackable(itemTypeId)
        return false

    int max = getItemMaxStacks(itemTypeId)
    for i = 0 to size-1
        with = u.itemInSlot(i)

        if with != itm and with.getTypeId() == itemTypeId
            curr = GetItemCharges(with)

            if curr < max
                diff = max - curr
                if diff > charges
                    SetItemCharges(with, curr + charges)
                    fireEvent(eventAddedTrigger, u, with, charges)
                else
                    SetItemCharges(with, max)
                    fireEvent(eventAddedTrigger, u, with, diff)
                charges -= diff
        if charges <= 0
            break

    if charges <= 0
        itm.remove()
    else if charges != GetItemCharges(itm)
        SetItemCharges(itm, charges)
    return true

function onPickUp()
    item itm = GetManipulatedItem()

    if isItemStackable(itm.getTypeId())
        stackItem(GetTriggerUnit(), itm)

function onMoved()
    unit u = getInventoryManipulatingUnit()
    item itm = getInventoryManipulatedItem()
    int slotFrom = getInventorySlotFrom()
    item with = getInventorySwappedItem()
    int curr
    int diff
    int charges = GetItemCharges(itm)
    int itemTypeId = itm.getTypeId()
    int size = u.inventorySize()
    int max
    int toSplit

    if not isItemStackable(itemTypeId)
        return

    max = getItemMaxStacks(itemTypeId)
    toSplit = getItemSplitCount(itemTypeId)

    if slotFrom == getInventorySlotTo() // splitting
        if charges < 2 // need at least 2
            return
        else if toSplit >= charges
            toSplit = charges - 1
        SetItemCharges(itm, charges - toSplit)
        fireEvent(eventRemoveTrigger, u, itm, toSplit)

        // Redistribute the splitted stacks if possible
        for i = 0 to size-1
            if i != slotFrom
                with = u.itemInSlot(i)
                if with.getTypeId() == itemTypeId
                    curr = GetItemCharges(with)
                    diff = max - curr
                    if diff > toSplit
                        SetItemCharges(with, curr + toSplit)
                        fireEvent(eventAddedTrigger, u, with, toSplit)
                    else
                        SetItemCharges(with, max)
                        fireEvent(eventAddedTrigger, u, with, diff)
                    toSplit -= diff
            if toSplit <= 0
                break
        if toSplit > 0 // something is left
            with = CreateItem(itemTypeId, u.getX(), u.getY())
            SetItemCharges(with, toSplit)
            trigger t = getPlayerUnitEventTrigger(EVENT_PLAYER_UNIT_PICKUP_ITEM)
            t.disable()
            UnitAddItem(u, with)
            t.enable()
    else if with.getTypeId() == itemTypeId
        curr = GetItemCharges(with)
        toSplit = charges + curr

        if toSplit > max
            if curr != max
                diff = max - charges
                SetItemCharges(itm, max)
                fireEvent(eventAddedTrigger, u, itm, diff)
                SetItemCharges(with, toSplit - max)
                fireEvent(eventRemoveTrigger, u, with, diff)
        else
            SetItemCharges(with, toSplit)
            fireEvent(eventAddedTrigger, u, with, charges)
            itm.remove()

function onSmoothPickup()
    stackItem(getSmoothItemPickupUnit(), getSmoothItemPickupItem())

function predicate() returns boolean
    let itemTypeId = GetOrderTargetItem().getTypeId()
    if not isItemStackable(itemTypeId)
        return false

    let u = GetTriggerUnit()
    return u.isInventoryFull() and not u.isItemFullyStacked(itemTypeId)

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM, () -> onPickUp())
    registerInventoryEvent(EVENT_INVENTORY_MOVED, () -> onMoved())
    registerSmoothItemPickupEvent(() -> onSmoothPickup())
    addSmoothPickupCondition(() -> predicate())
