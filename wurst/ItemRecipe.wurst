/*
*  ItemRecipe v1.1.0.0
*     by Bannar
*
*  Powerful item recipe creator.
*/
package ItemRecipe
import HashMap
import LinkedList
import RegisterEvents
import ItemRestriction
import InventoryEvent

// Global containers for associated recipe list retrieval
let recipeMap = new HashMap<int, LinkedList<ItemRecipe>>()
Table resultToRecipe = new Table()

// Event related globals
ItemRecipe eventRecipe = null
unit eventUnit = null
item eventItem = null
HashMap<int, ItemData> eventRecipeData = null
trigger eventAssemblingTrigger = CreateTrigger()
trigger eventAssembledTrigger = CreateTrigger()
boolean eventHandled = false

public constant int EVENT_ITEM_RECIPE_ASSEMBLING = 0
public constant int EVENT_ITEM_RECIPE_ASSEMBLED = 1

/** Returns triggering item recipe. */
public function getEventItemRecipe() returns ItemRecipe
    return eventRecipe

/** Returns recipe triggering unit. */
public function getEventItemRecipeUnit() returns unit
    return eventUnit

/** Returns event reward item. */
public function getEventItemRecipeItem() returns item
    return eventItem

/** Returns unit item slots mapped with respective ingredients chosen for assembly. */
public function getEventItemRecipeData() returns HashMap<int, ItemData>
    return eventRecipeData

/** Sets value indicating if event should be propagated. */
public function setEventItemRecipeHandled(boolean handled)
    eventHandled = handled

/** Registers new event handler for specified item recipe event. */
public function registerItemRecipeEvent(int whichEvent, code c)
    if whichEvent == EVENT_ITEM_RECIPE_ASSEMBLING
        eventAssemblingTrigger.addCondition(Condition(c))
    else if whichEvent == EVENT_ITEM_RECIPE_ASSEMBLED
        eventAssembledTrigger.addCondition(Condition(c))

/** Returns trigger handle associated with specified recipe event. */
public function getInventoryEventTrigger(int whichEvent) returns trigger
    if whichEvent == EVENT_ITEM_RECIPE_ASSEMBLING
        return eventAssemblingTrigger
    else if whichEvent == EVENT_ITEM_RECIPE_ASSEMBLED
        return eventAssembledTrigger
    return null

function fireEvent(trigger evt, ItemRecipe recipe, unit u, item itm, HashMap<int, ItemData> recipeData)
    ItemRecipe prevRecipe = eventRecipe
    unit prevUnit = eventUnit
    item prevItem = eventItem
    let prevRecipeData = eventRecipeData

    eventRecipe = recipe
    eventUnit = u
    eventItem = itm
    eventRecipeData = recipeData

    evt.evaluate()

    eventRecipe = prevRecipe
    eventUnit = prevUnit
    eventItem = prevItem
    eventRecipeData = prevRecipeData

/** Stores information about item required for recipe assembly. */
public class ItemData
    int itemTypeId
    boolean remove
    int charges
    int index

    construct(int itemTypeId, boolean remove, int charges, int index)
        this.itemTypeId = itemTypeId
        this.remove = remove
        this.charges = charges
        this.index = index
    
    construct(thistype base)
        this.itemTypeId = base.itemTypeId
        this.remove = base.remove
        this.charges = base.charges
        this.index = base.index

/** Item recipe, collection of items that can be combined for powerful rewards. */
public class ItemRecipe
    private LinkedList<ItemData> ingredients
    private int reward
    int charges
    boolean ordered
    boolean permanent
    boolean pickUp
    UnitRequirement requirement
    private int abilityId
    private int count
    private boolean batch

    construct(int reward, int charges, boolean ordered, boolean permanent, boolean pickUp)
        ingredients = new LinkedList<ItemData>()
        this.reward = reward
        this.charges = charges
        this.ordered = ordered
        this.permanent = permanent
        this.pickUp = pickUp
        requirement = null
        abilityId = 0

        resultToRecipe.saveInt(reward, this castTo int)

    ondestroy
        LinkedList<ItemRecipe> recipes
        int itemTypeId

        setAbility(0)
        resultToRecipe.removeInt(reward)

        for data in ingredients
            itemTypeId = data.itemTypeId
            recipes = recipeMap.get(itemTypeId)
            recipes.remove(this)
            if recipes.isEmpty()
                destroy recipes
                recipeMap.remove(itemTypeId)

        destroy ingredients

    /** Number of items required for the recipe. */
    function count() returns int
        return count

    /** Whether specified item type is a part of recipe. */
    function inList(int itemTypeId) returns boolean
        for data in ingredients
            if data.itemTypeId == itemTypeId
                return true
        return false

    /** Returns shallow copy of item recipe data. */
    function getRecipeData() returns LinkedList<ItemData>
        return new LinkedList<ItemData>(ingredients)

    /** Returns item type of this recipe reward. */
    function getResult() returns int
        return reward

    /** Starts single-reference counted batch. Allows to assign multiple items to the same item slot. */
    function startBatch()
        if not batch
            batch = true

    /** Closes current batch. */
    function endBatch()
        if batch
            batch = false
            count++

    /** Sets or removes specified ability from triggering recipe assembly. */
    function setAbility(int abilityId)
        LinkedList<ItemRecipe> recipes

        if this.abilityId == abilityId
            return

        if this.abilityId != 0
            recipes = recipeMap.get(abilityId)
            recipes.remove(this)
            if recipes.isEmpty()
                destroy recipes
                recipeMap.remove(abilityId)

        if abilityId > 0
            this.abilityId = abilityId
            if not recipeMap.has(abilityId)
                recipes = new LinkedList<ItemRecipe>()
                recipes.push(this)
                recipeMap.put(abilityId, recipes)
            else
                recipes = recipeMap.get(abilityId)
                if not recipes.contains(this)
                    recipes.push(this)

    /** Removes all entries that match specified item type from recipe ingredient list. */
    function removeItem(int itemTypeId)
        let iter = ingredients.iterator()
        boolean found = false

        while iter.hasNext()
            if iter.next().itemTypeId == itemTypeId
                iter.remove()
                found = true
        iter.close()

        if found
            let recipes = recipeMap.get(itemTypeId)
            recipes.remove(this)
            if recipes.isEmpty()
                destroy recipes
                recipeMap.remove(itemTypeId)

    /** Adds new entry to recipe ingredient list. */
    function addItem(int itemTypeId, boolean remove, int charges)
        LinkedList<ItemRecipe> recipes
        int chrgs = charges

        if itemTypeId <= 0 or itemTypeId == reward
            return
        if count >= bj_MAX_INVENTORY and not batch
            return

        if not recipeMap.has(itemTypeId)
            recipes = new LinkedList<ItemRecipe>()
            recipes.push(this)
            recipeMap.put(itemTypeId, recipes)
        else
            recipes = recipeMap.get(itemTypeId)
            if not recipes.contains(this)
                recipes.push(this)

        if chrgs < 0
            chrgs = 0

        let data = new ItemData(itemTypeId, remove, chrgs, count)
        ingredients.push(data)
        if not batch
            count++

    /** Adds new entry to recipe ingredient list. */
    function addItem(int itemTypeId)
        addItem(itemTypeId, true, 0)

    private function orderedSearch(unit u) returns HashMap<int, ItemData>
        int slot = 0
        boolean found = false
        item itm
        int charges
        ItemData data
        int idx
        HashMap<int, ItemData> reward = new HashMap<int, ItemData>()

        let iter = ingredients.iterator()..next()
        while iter.current != iter.dummy // Match() validated count > size already
            itm = u.itemInSlot(slot)
            charges = GetItemCharges(itm)
            data = iter.current.elem
            idx = data.index

            while data.index == idx // Treats each part of recipe as possible batch
                if itm.getTypeId() == data.itemTypeId and charges >= data.charges
                    reward.put(slot, new ItemData(data))
                    found = true
                    break

                if iter..next().current == iter.dummy
                    break
                data = iter.current.elem

            if not found
                destroy reward
                iter.close()
                return null
            else
                // Seek node which is not part of this batch
                while data.index == idx
                    if iter..next().current == iter.dummy
                        break
                    data = iter.current.elem
            slot++
        iter.close()
        return reward

    private function unorderedSearch(unit u) returns HashMap<int, ItemData>
        boolean found
        ItemData data
        int idx
        int slot
        int size = u.inventorySize()
        item itm
        int itemTypeId
        int charges
        HashMap<int, ItemData> reward = new HashMap<int, ItemData>()

        let iter = ingredients.iterator()..next()
        while iter.current != iter.dummy
            found = false
            data = iter.current.elem
            idx = data.index

            // Attempt to find any of item types from given batch within inventory
            while data.index == idx
                slot = 0
                while slot < size
                    if not reward.has(slot)
                        itm = u.itemInSlot(slot)
                        itemTypeId = itm.getTypeId()
                        charges = GetItemCharges(itm)

                        if itemTypeId == data.itemTypeId and charges >= data.charges
                            reward.put(slot, new ItemData(data))
                            found = true
                            break
                    slot++

                if found
                    break
                if iter..next().current == iter.dummy
                    break
                data = iter.current.elem

            if not found
                destroy reward
                iter.close()
                return null
            else
                iter.next()
                while data.index == idx
                    if iter..next().current == iter.dummy
                        break
                    data = iter.current.elem
        iter.close()
        return reward

    private function match(unit u) returns HashMap<int, ItemData>
        if count <= 0 or count > u.inventorySize()
            return null
        else if requirement != null and not requirement.filter(u)
            return null

        if ordered
            return orderedSearch(u)
        return unorderedSearch(u)

    /** Attempts to assembly this recipe for specified unit. */
    function assembly(unit u) returns boolean
        boolean prevHandled = eventHandled
        int size = u.inventorySize()
        ItemData data
        item itm
        int chrgs

        let recipeData = match(u)
        if recipeData == null
            return false

        eventHandled = false
        fireEvent(eventAssemblingTrigger, this, u, null, recipeData)
        if eventHandled
            eventHandled = prevHandled
            return false

        for i = 0 to size
            if recipeData.has(i)
                data = recipeData.get(i)
                itm = u.itemInSlot(i)
                if data.charges > 0
                    chrgs = GetItemCharges(itm)
                    if chrgs > data.charges and not data.remove
                        SetItemCharges(itm, chrgs - data.charges)
                    else
                        itm.remove()
                else if data.remove
                    itm.remove()

        itm = CreateItem(reward, u.getX(), u.getY())
        if charges > 0
            SetItemCharges(itm, charges)
        UnitAddItem(u, itm)

        eventHandled = prevHandled
        fireEvent(eventAssembledTrigger, this, u, itm, recipeData)
        return true

    /** Reverts the assembly, removing the reward item and returning all ingredients to specified unit. */
    function disassembly(unit u) returns boolean
        int size = u.inventorySize()
        boolean found = false
        item itm = null

        if permanent
            return false

        for i = 0 to size
            itm = u.itemInSlot(i)
            if itm.getTypeId() == reward
                found = true
                break
        if not found
            return false

        itm.remove()
        for data in ingredients
            if data.remove
                itm = CreateItem(data.itemTypeId, u.getX(), u.getY())
                if data.charges > 0
                    SetItemCharges(itm, data.charges)
                UnitAddItem(u, itm)
        return true

/** Attempts to assemble specified item type for provided unit. */
public function assemblyItem(unit u, int itemTypeId) returns boolean
    if not resultToRecipe.hasInt(itemTypeId)
        return false

    let recipe = resultToRecipe.loadInt(itemTypeId) castTo ItemRecipe
    return recipe.assembly(u)

/** Reverts the assembly, removing the reward item and returning all ingredients to specified unit. */
public function disassemblyItem(unit u, item itm) returns boolean
    int itemTypeId = itm.getTypeId()
    if not u.hasItem(itm) or not resultToRecipe.hasInt(itemTypeId)
        return false

    let recipe = resultToRecipe.loadInt(itemTypeId) castTo ItemRecipe
    return recipe.disassembly(u)

function onInventoryChange(unit u, item itm)
    int itemTypeId = itm.getTypeId()

    if recipeMap.has(itemTypeId)
        let recipes = recipeMap.get(itemTypeId)
        for recipe in recipes
            if recipe.pickUp and recipe.assembly(u)
                break

function onPickUp()
    onInventoryChange(GetTriggerUnit(), GetManipulatedItem())

function onMoved()
    onInventoryChange(getEventInventoryUnit(), getEventInventoryItem())

function onCast()
    unit u
    int abilityId = GetSpellAbilityId()

    if recipeMap.has(abilityId)
        u = GetTriggerUnit()
        let recipes = recipeMap.get(abilityId)
        for recipe in recipes
            recipe.assembly(u)

init
    registerPlayerUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM, () -> onPickUp())
    registerInventoryEvent(EVENT_INVENTORY_MOVED, () -> onMoved())
